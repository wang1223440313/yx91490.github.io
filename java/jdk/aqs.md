# 【译】AbstractQueuedSynchronizer概览

等待队列是“CLH”(Craig, Landin, andHagersten)锁队列的一个变种。CLH锁通常用于自旋锁。我们用它来作为阻塞同步器，包括引入显式(“prev”和“next”)链接和一个“status”字段，允许节点在释放时向后继节点发出信号锁定，并处理由于中断和超时而导致的取消。状态字段包含跟踪线程是否需要信号(使用LockSupport.unpark)	的比特位。尽管有这些补充，我们保持大多数CLH局部属性。

要排队进入一个CLH锁，您可以原子地将其拼接为新锁tail。要退出队列，您需要设置头字段，以便下一个符合条件的等待者成为第一个。

```
  +------+  prev +-------+       +------+
  | head | <---- | first | <---- | tail |
  +------+       +-------+       +------+
```

插入到CLH队列只需要尾部的一个原子操作，所以从未排队到排队有一个简单的分界点。predecessor的“next”链接是在CAS成功后由排队线程设置。尽管非原子性，这足以确保当符合条件时由predecessor向任何阻塞线程发出信号(尽管在取消这种情况下，在方法cleanQueue中可能存在帮助信号)。信号传输部分是基于类似dekker的方案，其中将要等待的线程表明WAITING状态，然后重试获取，然后在阻塞前重新检查状态。当unparking的时候信号器原子地清除等待状态。

acquire时的出队操作包括分离节点的“prev”节点，然后更新head节点。其他线程通过检查prev来判断节点是否被出队。我们通过强制置空，然后通过自旋等待（如果有必要的话）排序。因此，锁算法自身不是严格的“无锁”，因为加锁线程可能需要前一次加锁。当与排他锁一起使用时，无论如何都需要这样的过程。然而共享模式在设置head前前可能(不常见)需要自旋等待，确保正确的传播。(注意:与这个类以前的版本相比有了些简化和效率提升)

一个节点的predecessor可能会因为取消等待而改变，直到节点排在队列的第一个，此时它不能改变。acquire方法通过在等待前重新检查prev来处理这个问题。仅能通过方法cleanQueue以CAS方式取消节点的时候修改prev和next字段。这个策略让人联想到Michael-Scott队列，在和prev字段成功CAS后，其他线程会提供帮助修复next字段。因为取消通常是成批发生的，这使得每一个必要的信号的决定变得复杂，cleanQueue的每次调用将遍历队列，直到清除干净。节点重新成为头节点，会被无条件的unpark(有时是不必要的，但这些情况不值得避免)。

线程可能会尝试acquire，如果它在队列最前面。成为第一名并不能保证成功;它只给了你竞争的权利。我们通过允许传入线程，以及在处理入队的过程中获得同步器（在这种情况下，第一个被唤醒的线程可能需要rewait），来实现吞吐量、开销和公平性的平衡。为了抵消可能重复的不幸等待，我们每次获得的重试次数呈指数增长(最多256次)线程被取消。除了这种情况，AQS锁不会自旋;相反，他们交错尝试获得记账的步骤？。(想要自旋锁的用户可以使用tryAcquire)。

为了提高垃圾收集能力，没在列表上的节点的属性是null。(创建然后扔掉一个Node却不使用它的情况并不罕见)。从列表中退出的节点的字段会尽快取消。这加剧了从外部确定第一个等待线程的挑战(如方法getFirstQueuedThread)。当字段显示为空时，有时需要回退到，从原子更新tail的语句向后遍历。(然而在信号传递的过程不需要)

CLH队列需要一个虚拟头节点来启动。但我们不会在构造时创建它，因为如果没有竞争会浪费努力。相反，在第一次竞争时，构造该节点，并设置头和尾指针。

共享模式操作与独占模式操作的区别在于一个acquire会通知下一个waiter让他尝试acquire。tryacquirered API允许用户指示传播的程度，但在大多数应用中，忽略这一点并且在任何情况下获得让后继者去尝试acquire会更高效。

等待Condition的线程使用附加的节点链接以维护(FIFO)Condition列表。Condition只需要在简单(非并发)链接队列中链接节点，因为它们只在独占持有时被访问。在Await时，节点被插入到条件队列中。在signal时,节点被放入主队列。一个特殊的状态字段值用于跟踪并原子触发此操作。

对字段head、tail和state的访问完全使用Volatile模式，以及CAS。节点字段status, prev和next也如此，当线程是可通知的，否则有时使用更弱的模式。访问字段“waiter”(要访问的线程)有信号的)总是夹在其他原子访问之间，因此在Plain模式下使用。我们使用jdk.internal Unsafe版本中的原子访问方法，而不是VarHandles，以避免潜在的虚拟机引导问题。

以上大部分都是由主要的内部方法acquire执行的，它被所有导出的Acquire()方法以某种方式调用方法。(当大量使用时，编译器通常很容易优化调用的特殊化)

关于何时和如何检查中断阻塞，在acquire和await之前和/或之后有几个武断的决定。但是却很少更新具体的实现，因为一些用户似乎依赖原始行为，总体上(很少)是错误的，但很难为改变。

感谢Dave Dice, Mark Moir, Victor Luchangco, BillScherer和Michael Scott，以及JSR-166的成员专家小组，提供有益的想法，讨论和批评关于这个类的设计。

## 参考

[AbstractQueuedSynchronizer.java](https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java)