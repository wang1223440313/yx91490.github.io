# 3种让线程等待和唤醒的方法

3种让线程等待/唤醒的方法：

1. 使用Object中的`wait()`方法让线程等待，使用Object中的notify()方法唤醒线程
2. 使用juc包中Condition的await()方法让线程等待，使用signal()方法唤醒线程
3. 使用LockSupport的park()系列方法阻塞当前线程，使用unpark方法或者调用等待线程的 interrupt()方法唤醒线程

3种方式对比：

|                                        | Object                   | Condtion           | LockSupport |
| :------------------------------------- | :----------------------- | :----------------- | :---------- |
| 前置条件                               | 需要在synchronized中运行 | 需要先获取Lock的锁 | 无          |
| 无限等待                               | 支持                     | 支持               | 支持        |
| 超时等待                               | 支持                     | 支持               | 支持        |
| 等待到将来某个时间返回                 | 不支持                   | 支持               | 支持        |
| 等待状态中释放锁?                      | 会释放                   | 会释放             | 不会释放    |
| 唤醒方法先于等待方法执行，能否唤醒线程 | 否                       | 否                 | 可以        |
| 是否能响应线程中断                     | 是                       | 是                 | 是          |
| 线程中断是否会清除中断标志?            | 是                       | 是                 | 否          |
| 是否支持等待状态中不响应中断?          | 不支持                   | 支持               | 不支持      |

关于Object类中的用户线程等待和唤醒的方法，总结一下：

- `wait(), notify(), notifyAll()`方法都必须放在同步代码中执行，需要先获取锁

- 线程唤醒的方法`notify(), notifyAll()`需要在等待的方法`wait`之后执行，等待中的线程才可能会被唤醒，否则无法唤醒

关于Condition中方法使用总结：

- 使用Condition中的线程等待和唤醒方法之前，需要先获取锁

- `signal()`方法先于`await()`方法之前调用，线程无法被唤醒

## 参考

- [java高并发系列 - 第14天:JUC中的LockSupport工具类，必备技能]()