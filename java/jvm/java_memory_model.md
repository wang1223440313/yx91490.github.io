#### java内存模型

JVM规范说，Java程序在各个os平台下必须实现一次编译，到处运行的效果！故JVM规范定义了一个模型来屏蔽掉各类硬件和os之间内存访问的差异（比如Java的并发程序必须在不同的os下运行效果是一致的）这个模型就是Java的内存模型。通俗的说：Java内存模型定义了把JVM中的变量存储到内存和从内存中读取出变量的访问规则，这里的变量不算Java栈内的局部变量。

所有的变量(实例字段、静态字段和构成数组对象的元素，不包括局部变量与方法参数)都存储在主内存中，每条线程还有自己的工作内存（类比处理器高速缓存），保存了被该线程使用到的变量的主内存副本拷贝。线程对变量的所有读取赋值等操作都必须在工作内存中进行，而不能直接读写主内存的变量。

多线程程序主要关注两个问题：

（1）共享变量可见性问题

（2）代码重排序一致性问题

java内存模型定义了8种操作完成如何从工作内存同步到主内存的实现细节。

当数据从JVM的主内存复制一份拷贝到Java线程的工作内存存储时，必须出现两个动作：

- 由JVM主内存执行的读（read）操作
- 由Java线程的工作内存执行相应的load操作

反过来，当数据从线程的工作内存拷贝到JVM的主内存时，也出现两个操作：

- 由Java线程的工作内存执行的存储（store）操作；
- 由JVM主内存执行的相应的写（write）操作

read，load，store，write的操作都是原子的，即执行期间不会被中断，但是各个原子操作之间可能会发生中断。对于普通变量，如果一个线程中那份JVM主内存变量值的拷贝更新了，并不能马上反应在其他变量中，因为Java的每个线程都私有一个工作内存，里面存储了该条线程需要用到的JVM主内存中的变量拷贝！

**对于volatile变量的特殊规则**

1. 保证此变量对所有线程的可见性
2. 禁止指令重排序优化(你看到的代码顺序，不一定是它的执行顺序)

volatile只保证了可见性，不保证原子性

long和double的非原子性协定

**原子性**

1. 基本数据类型的读写是原子性的
2. syncronized修饰的原子性

**可见性**

1. volitile保证了多线程操作时变量的可见性，而普通变量不能保证
2. synchronized和final

**有序性**

1. 如果在本线程内观察所有的操作都是有序的（线程内表现为串行的语义）
2. 如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序现象和工作内存与主内存同步延迟）

java提供了volatile和synchronized关键字来保证线程之间的有序性

#### happens-before原则

程序次序规则  一段代码的执行在单个线程中看起来是有序的

管程锁定规则 一个unLock操作先行发生于后面对同一个锁的lock操作

volatile变量规则 对一个变量的写操作先行发生于后面对这个变量的读操作

线程启动规则

线程终止规则

线程中断规则

对象终结规则

传递性

#### java线程状态

1. 新建
2. 运行 （包括操作系统线程状态中的running和ready）
3. 无限期等待 等待被其他线程唤醒（没有设置timeout的object.wait()方法，没有timeout的thread.join()方法,LockSupport.park()）
4. 限期等待 等待一段时间(Thread.sleep(), Object.wait(timeout), Thread.join(timeout), LockSupport.parkNanos(), LockSupport.parkUntil())
5. 阻塞 阻塞状态与等待状态的区别是 阻塞状态在等待获取一个排它锁，等待状态等待一段时间或者唤醒动作
6. 结束

#### 线程安全的实现方法

1. 互斥同步

   同步指在多个线程并发访问共享数据时保证共享数据在同一个时刻只被一个线程使用。互斥是实现同步的手段，临界区、互斥量、信号量是主要的互斥方式。

2. 非阻塞同步

   如cas

3. 无同步方案

   1. 可重入代码
   2. 线程本地存储